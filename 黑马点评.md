![[Pasted image 20250929162457.png]]


[黑马点评面试要点 | KNeegcyao](https://kneegcyao.github.io/posts/bbf9fa63.html)
https://cyborg2077.github.io/2022/10/22/RedisPractice/

基础学习 上面是实战内容（这个是mq优化后的 现在还没学mq先不看这个）
https://blog.csdn.net/weixin_52574640/article/details/129998255

黑马点评讲义：
[redis/02-实战篇/讲义/02-Redis企业实战.pptx at main · spongehah/redis](https://github.com/spongehah/redis/blob/main/02-%E5%AE%9E%E6%88%98%E7%AF%87/%E8%AE%B2%E4%B9%89/02-Redis%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98.pptx)
Redis 哨兵模式是为了实现高可用性而设计的，它利用哨兵进程来监控主从节点，并在主节点故障时自动将从节点升级为新的主节点 而Redis 集群模式（Cluster）则是为了解决单机Redis 的容量和性能瓶颈，通过数据分片（Sharding）将数据分散存储在多个节点上，实现真正的分布式存储、高并发和线性扩展。 
redis设置密码需要在config文件中 修改requirepass 密码  **本机redis密码为123456**
默认把接收的object采用jdk序列化存入到redis当中：\xac\xed\x00\x05t\x00\x04jack。可以自定义序列化方式
**Redis连接工厂**是Spring Data Redis中的一个接口，它提供了创建和管理Redis连接的方法。使用RedisConnectionFactory可以获取到Redis连接对象，然后通过该对象对Redis进行存储、查询、删除等操作。
JDK序列化：可读性差 占用存储空间大-->json序列化 可读性好 占用空间大 -->string 序列化可读性好 不会存入多余数据
idea使用技巧：【CTRL + f12】查看当前类下所有方法


2025.9.30
ngnix启动失败：**需要在文件夹中创建一个temp文件夹**
ctrl + i 实现方法重写

==**git怎么推送怎么拉取感觉还是要看看的 还有一些中间件都得看看**==

为了防止过高的数据访问冲击系统，从而导致操作线程无法处理信息而瘫痪 实际开发中需要加入缓存技术。cache 数据交换的缓冲区 一般从数据库获取 存储于本地代码。 缓存可以降低用户访问并发量带来的服务器读写压力。
模型：查询缓存数据--查询数据库 缓存数据存在从缓存中返回 缓存数据不存在 查询数据库 再存入redis。

缓存更新：当redis中有太多数据 redis会对部分数据进行更新（淘汰） 
内存淘汰：即当redis内存达到设定的max-memery自动触发淘汰机制。一致性差 维护成本无
超时剔除：设置过期时间ttl之后 redis将超时的数据删除  一致性一般 维护成本低
主动更新：可以手动删除缓存 用于解决缓存和数据库不一致问题 一致性好 维护成本高
商品缓存与数据库双写一致进行postman测试时 请求头上要加上authorization = token（之前登录时产生的token 否则会报401错误）
![[Pasted image 20251002133620.png]]
缓存穿透：客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。
解决方案：1.缓存空对象  2.布隆过滤（布隆过滤器check，无是绝对无，有是可能有）

缓存雪崩：redis中大量key在同一时间失效或者redis宕机 大量请求打到数据库中
解决：
- 给不同的Key的TTL添加随机值，将失效时间分布在一个时间段内而不是同一时间点
- 利用Redis集群提高服务的可用性（预防宕机）
- 给缓存业务添加降级限流策略（SpringCloud）
- 给业务添加多级缓存（浏览器缓存，Nginx缓存，Tomcat缓存，JVM缓存等待）

缓存击穿（热点key）：被**高并发访问**并且**缓存重建业务较复杂**的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。多个线程同时查找缓存都没找到 又同时访问数据库 对数据库造成影响。
==解决？？==：
1.互斥锁 实现简单 数据一致性 但是可能引发死锁 并且并行的只能串行 对性能有一定影响 （cp需求 强调一致性） 利用redis的setnx实现操作锁 需要对锁设置有效期

2.逻辑过期 性能好 不保证数据一致性 但实现麻烦 （ap需求强调可用性）

优惠券秒杀：
@Resource：默认按名称装配，如果找不到匹配的 bean 名称，则按类型装配
@Autowired：默认按类型装配，如果有多个相同类型的 bean，再按名称匹配

超卖问题
悲观锁：添加同步锁 让线程串行执行 简单但是性能一般
乐观锁解决超卖问题：不加锁 再更新时判断是否有其他线程修改  关键在于判断之前查询的数据是否被修改过
1.版本号法 
2.CAS法（compare and switch）乐观锁线程是安全的但是失败率很高 可以改进一下 对于库存来说不需要更改时库存数量和之前查询的库存数量一致 只要库存>0即可

**一人一单（悲观锁实现？？）**
通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。
202.10.3 分布式锁：多进程可见，互斥，高可用，高性能，安全性。

常见的分布式锁：MySQL Redis Zookeeper
setnx设置锁 expire设置超时时间ttl  del释放锁  为了让设置锁和超时时间是一个原子操作，可以同时设置两者 set lock 线程 NX EX 超时时间

解决分布式锁误删问题：在删除锁之前判断一下当前锁是否是自己的锁，即获取锁时存入线程标示，在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致，一致释放 不一致不释放锁。

lua脚本解决多跳命令原子性问题：在一个lua脚本中编写多条Redis命令，确保多条命令执行时的原子性
脚本中写：redis.call('命令名称', 'key', '其它参数', ...)
调用脚本： EVAL "return redis.call('set','name','jack')" 0 //后面的数字代表key类型的参数有几个。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数。【lua语言中数组下标初始为1】

基于setnx实现的分布式锁：
存在的问题：
1.不可重入 同一个线程无法多次获取同一个锁
2.不可重试 获取锁只尝试一次就返回false 无重传机制
3.超时释放 加锁时增加了过期时间，可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患
4.主从一致性

redission锁：可重入锁
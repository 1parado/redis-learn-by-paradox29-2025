![[Pasted image 20250929162457.png]]


[黑马点评面试要点 | KNeegcyao](https://kneegcyao.github.io/posts/bbf9fa63.html)
https://cyborg2077.github.io/2022/10/22/RedisPractice/

基础学习 上面是实战内容（这个是mq优化后的 现在还没学mq先不看这个）
https://blog.csdn.net/weixin_52574640/article/details/129998255

黑马点评讲义：
[redis/02-实战篇/讲义/02-Redis企业实战.pptx at main · spongehah/redis](https://github.com/spongehah/redis/blob/main/02-%E5%AE%9E%E6%88%98%E7%AF%87/%E8%AE%B2%E4%B9%89/02-Redis%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98.pptx)
Redis 哨兵模式是为了实现高可用性而设计的，它利用哨兵进程来监控主从节点，并在主节点故障时自动将从节点升级为新的主节点 而Redis 集群模式（Cluster）则是为了解决单机Redis 的容量和性能瓶颈，通过数据分片（Sharding）将数据分散存储在多个节点上，实现真正的分布式存储、高并发和线性扩展。 
redis设置密码需要在config文件中 修改requirepass 密码  **本机redis密码为123456**
默认把接收的object采用jdk序列化存入到redis当中：\xac\xed\x00\x05t\x00\x04jack。可以自定义序列化方式
**Redis连接工厂**是Spring Data Redis中的一个接口，它提供了创建和管理Redis连接的方法。使用RedisConnectionFactory可以获取到Redis连接对象，然后通过该对象对Redis进行存储、查询、删除等操作。
JDK序列化：可读性差 占用存储空间大-->json序列化 可读性好 占用空间大 -->string 序列化可读性好 不会存入多余数据
idea使用技巧：【CTRL + f12】查看当前类下所有方法


2025.9.30
ngnix启动失败：**需要在文件夹中创建一个temp文件夹**
ctrl + i 实现方法重写

==**git怎么推送怎么拉取感觉还是要看看的 还有一些中间件都得看看**==

为了防止过高的数据访问冲击系统，从而导致操作线程无法处理信息而瘫痪 实际开发中需要加入缓存技术。cache 数据交换的缓冲区 一般从数据库获取 存储于本地代码。 缓存可以降低用户访问并发量带来的服务器读写压力。
模型：查询缓存数据--查询数据库 缓存数据存在从缓存中返回 缓存数据不存在 查询数据库 再存入redis。

缓存更新：当redis中有太多数据 redis会对部分数据进行更新（淘汰） 
内存淘汰：即当redis内存达到设定的max-memery自动触发淘汰机制。一致性差 维护成本无
超时剔除：设置过期时间ttl之后 redis将超时的数据删除  一致性一般 维护成本低
主动更新：可以手动删除缓存 用于解决缓存和数据库不一致问题 一致性好 维护成本高
商品缓存与数据库双写一致进行postman测试时 请求头上要加上authorization = token（之前登录时产生的token 否则会报401错误）
![[Pasted image 20251002133620.png]]
缓存穿透：客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。
解决方案：1.缓存空对象  2.布隆过滤（布隆过滤器check，无是绝对无，有是可能有）

缓存雪崩：redis中大量key在同一时间失效或者redis宕机 大量请求打到数据库中
解决：
- 给不同的Key的TTL添加随机值，将失效时间分布在一个时间段内而不是同一时间点
- 利用Redis集群提高服务的可用性（预防宕机）
- 给缓存业务添加降级限流策略（SpringCloud）
- 给业务添加多级缓存（浏览器缓存，Nginx缓存，Tomcat缓存，JVM缓存等待）

缓存击穿（热点key）：被**高并发访问**并且**缓存重建业务较复杂**的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。多个线程同时查找缓存都没找到 又同时访问数据库 对数据库造成影响。
==解决？？==：
1.互斥锁 实现简单 数据一致性 但是可能引发死锁 并且并行的只能串行 对性能有一定影响 （cp需求 强调一致性） 利用redis的setnx实现操作锁 需要对锁设置有效期

2.逻辑过期 性能好 不保证数据一致性 但实现麻烦 （ap需求强调可用性）

优惠券秒杀：
@Resource：默认按名称装配，如果找不到匹配的 bean 名称，则按类型装配
@Autowired：默认按类型装配，如果有多个相同类型的 bean，再按名称匹配

超卖问题
悲观锁：添加同步锁 让线程串行执行 简单但是性能一般
乐观锁解决超卖问题：不加锁 再更新时判断是否有其他线程修改  关键在于判断之前查询的数据是否被修改过
1.版本号法 
2.CAS法（compare and switch）乐观锁线程是安全的但是失败率很高 可以改进一下 对于库存来说不需要更改时库存数量和之前查询的库存数量一致 只要库存>0即可

**一人一单（悲观锁实现？？）**